1) Katmanlı Mimari: Piyasadaki Java uygulamaları genel olarak katmanlı mimari ile yazılır, yani tüm kodlar main içerisine yazılmaz. Main olabildiğince temiz tutulmaya çalışılır, kalabalık kodlar ise çeşitli katmanlara yerleştirilir. Bu katmanlar nelerdir, hangisi hangi kodu barındırır? Arayüz katmanından başlayalım. Arayüz, uygulamayı kullanan kişinin doğrudan muhatap olduğu katmandır. Swing ile üzerinde düğmeler olan bir pencere tasarladıysak bu bir arayüzdür. Arayüzümüz web sayfaları veya mobil uygulama şeklinde de olabilir. Arayüzden gelen istek ya da bilgilerin programımızla iletişime geçtiği katman Controller (kontrolcü, yönetici) katmanıdır. Controller, arayüz katmanıyla İş/Servis katmanı arasında yer alır. Arayüz, veritabanında saklı bir bilgiyi talep ettiği zaman Controller, bu bilgiyi İş katmanından ister. Arayüz, veritabanına kaydedilmesi için bir bilgi gönderdiğinde Controller yine bunu İş katmanına havale eder. İş katmanı, Controller katmanıyla Veri Erişim katmanı arasında yer alır. Bir sorgu geldiğinde onun çeşitli şartları sağlayıp sağlamadığını teyit eder. Örneğin bir alışveriş web sitesi inşa ettik. Buradan alışveriş yapmak isteyen bir kullanıcı önce kendi seçtiği eposta adresi ve şifre ile sisteme kayıt olmalıdır. "Kayıt ol" düğmesine bastığı anda arayüzden Controller katmanına bilgi gelir. Controller katmanı İş katmanına yeni kullanıcının bilgisini gönderir. İş katmanında ise böyle bir eposta adresi zaten var mı yok mu diye kontrol edilir. Şifresi belli bir uzunluğu sağlıyor mu gibi kriterler de uygulanabilir. Eğer şartlar sağlanıyorsa, veritabanına kayıt yapılması için bu bilgi Veri Erişim Katmanına (Data Access Layer / Data Access Object) yollanır. Veri Erişim katmanı, veritabanıyla doğrudan muhatap olan katmandır.
Şeklen:
[ARAYÜZ] - [CONTROLLER] - [İŞ] - [VERİ ERİŞİM] - (Veri tabanı)

2) REST API: Api'ın açılımı Application Package Interface'tir (Uygulama paket arabirimi). Farklı dille çalışan programların birbiriyle konuşabilmesini sağlar. Bizim Java ile geliştirdiğimiz uygulama eğer Web sayfası şeklinde bir arayüze sahip olacaksa, Web sayfasından gelen istekleri Java diline çeviren bir arabirim lazımdır, işte buna Rest Api diyoruz. Web sayfasından gelen istekler normalde Java dilinde değildir, HTTP dilindedir. Sık kullanılan 4 HTTP komutu Get, Post, Put ve Delete'tir. Get: Veritabanından bilgi isteme (SELECT). Post: Veritabanına bilgi kaydetme (INSERT). Put: Veritabanındaki bilgiyi güncelleme (UPDATE). Delete: Veritabanındaki kaydı silme (DELETE). Yukarıda katmanları anlatırken Controller katmanından bahsetmiştim. İşte Controller katmanı, Web'den gelen HTTP dilindeki bu komutları Java koduna dönüştürerek İş katmanına yolluyor. Diğer deyişle, Controller katmanı = Rest Api. Http'den Java diline dönüşüm nasıl mı yapılıyor? Swing'in bize sağladığı, @Annotation dediğimiz şerh sistemiyle. Controller katmanındaki sınıfınızın tanımının tepesine, yani public class ifadesinin hemen üstüne @RestController şerhi koyarsanız, bu artık http dilini java diline çevirecek yeteneğe kavuşuyor. Daha fazla bilgi spring kısmında.

3) MAVEN: Projemize bağımlılıkları (jar dosyalarını) elle eklemek mümkün ama bağımlılıkların sayısı arttıkça bunları hata yapmadan yönetmek, yeni bilgisayarlara aktarmak, güncellemesi gelenlerin güncellemelerini yapmak zahmetli hale geliyor. Burada maven imdadımıza yetişiyor. Maven üzerinden oluşturulmuş Java projelerinde pom.xml diye bir dosya bulunur. Projeye bağımlılıklar eklememiz gerektiğinde pom.xml dosyasını açarız, dependencies etiketini buluruz, lazım olan bağımlılığın dependency kodunu yazarız (bu kodlar internette mevcut). Kaydettiğimiz (ve projeyi güncellemek gerekiyorsa güncellediğimiz) zaman maven eksik tüm bağımlılıkları internetten indirip projeye ekler. İnternetten indirilen tüm jar'lar bilgisayarda bir klasörde depolanır. Eğer xml dosyasına yazdığımız bağımlılık internetten daha önce indirilmişse ve daha güncel versiyonu çıkmamışsa yeniden indirme yapmadan o klasörden getirilir. Çok faydalı bir araç. Spring-boot üzerinden proje oluşturduysak bunlarda maven otomatik olarak mevcuttur.

4) JDBC: Diyelim ki arayüzümüz hazır, controller katmanımız hazır, gerekli şartların sağlanıp sağlanmadığına bakacak iş katmanı da hazır, sıra geldi veritabanına veri kaydeden ya da ondan veri çeken yapıyı kurmaya. Veri erişim katmanından bahsediyoruz. Bu katmanın veritabanıyla iletişime geçmesini sağlayan yollardan biri JDBC (Java Database Connectivity) kütüphanesidir. C#'tan geliyorsanız bunu Ado.Net'e benzetebiliriz. Tüm select, insert, update, delete, create, drop, sort, group by vesaire sql sorgularını bu kütüphane sayesinde yazabilirsiniz. Hızlı çalışan bir yapısı vardır ama elle çok kod yazmayı gerektirir. İleride veritabanı tablolarınızda değişiklik yapmanız gerektiğinde jdbc ile yazdığınız kodları da değiştirmeniz gerekecektir.

5) JPA: JDBC hızlı olmasına karşın çok kod yazmayı gerektirdiğinden bu işi otomatiğe bağlayacak bir yapı arayışı doğmuştur. JPA (Java Persistance Api), bu otomatik yapıyı oluşturmak üzere yol göstermek için yazılmış geniş bir Interface (arabirim) kütüphanesidir. Bir nevi, binanın iskelet halidir. Hatırlayacağımız gibi arabirimler (interface'ler) doğrudan kullanılamaz çünkü metodlarının içleri boştur. Arabirimi değil de o arabirimi uyarlamış (implement etmiş) sınıfları kullanmamız gerekir. İşte burada Hibernate devreye giriyor (açıklaması aşağıda). Bu arada Persistance kelimesi normalde inat, kararlılık gibi anlamlara sahiptir. Programcılar arasında ise kaydetme (save) anlamına gelir. Mesela bir veriyi veritabanına kaydettiğiniz zaman o veriyi "persist etmiş" oluyorsunuz.

6) HIBERNATE: JPA denilen arabirim kütüphanesini uyarlamış iki meşhur sınıf kütüphanesi var. Bunlardan biri Hibernate, diğeri EclipseLink'tir. Hibernate daha yaygındır. İkisinin arasında çok önemli fark yoktur. Birini kullanmaktayken vaz geçip, fazla zahmete girmeden diğerini kullanmaya da başlayabilirsiniz. Hibernate aslında bir API'dır, yani iki farklı dilde çalışan sistemin birbiriyle konuşabilmesini sağlar, tercümanlık görevi üstlenir. Bizim java uygulamamız Java dilinde çalışıyor, veritabanları ise SQL dediğimiz bir dil kullanıyor. Java - SQL arası tercümanlığından dolayı Hibernate bir Api'dır. Doğrudan SQL kodları (nativeQuery) yazmamıza olanak verdiği gibi, HQL (Hibernate Query Language) denilen bir dille de çalışır. HQL, SQL diline benzer. Hibernate'in kendine ait bir @Şerh (@Annotation) sistemi vardır. Bunu swing'e ait olanlarla karıştırmamalıyız. Hibernate'inkiler @Table(name="Sehir"), @Column, @Id ve benzeri tiptendir, veritabanıyla ilgili terimleri kapsar, iş katmanında kullanılır.

Hibernate'i uygulamamıza dahil etmek için kullanacağımız bağımlılık (dependency) kodu (Küçüktür büyüktür işaretleri düzgün gözükecek mi bilmiyorum):


    org.hibernate
    hibernate-core


Ama ilginç birşey var: Ders 6.5'te, dakika 4:40'ta @Table isimli, Hibernate kökenli şerh çalışmıyordu, hem de import javax.persistence.Entity; yazmamıza rağmen. Bu şerhin ve importun çalışabilmesi için pom.xml dosyasında bağımlılıklar içine hibernate-core'un yüklenmesi gerekiyor. Fakat dikkat ederseniz dakika 5:00'da hibernate-core yerine spring-boot-starter-data-jpa bağımlılığı yüklendi ve şerh çalışmaya başladı. Aklınıza şu soru gelebilir: "Sen JPA'nın bir interface kütüphanesi olduğunu, doğrudan kullanılamayacağını, onun yerine onu uyarlayan hibernate'in kullanılması gerektiğini söylemiştin. Nasıl oldu da pom.xml'de hibernate'in adını anmadan JPA bağımlılığı yüklediğimizde @Table çalışmaya başladı?". Benim de aklıma takılmıştı orası ama internette araştırınca öğrendim ki spring-boot-starter-data-jpa bağımlılığı, ismi JPA olsa da JPA'dan ibaret değil, içerisinde spring data, hibernate, HikariCP, JPA API, JPA uyarlaması (Ön tanımlı olarak Hibernate), JDBC ve diğer lüzumlu kütüphaneleri barındırıyor. O yüzden bu bağımlılık kodunu yazmak, projeye hibernate'i yüklemek anlamına da geliyor.

7) SPRING: Java projelerimizde katmanlardan  biri diğerini doğrudan new'liyorsa iki katman arası bağımlılık oluşur. New'lenmiş olan katmanda kodlar üzerinde değişiklik yapıldığında, bu, new'leyenin çalışmasını da bozabilir. Sıkıntı sadece bundan ibaret değil, katmanların birbirine bağlı olduğu projelerin sürdürülürlüğü (yani sonradan gelen kişinin kodu anlayabilmesi) de olumusuz etkilenir, başka sorunlar da ortaya çıkabilir. Bunun önüne geçmek için arabirimlerden yararlanıyorduk, bağımlılık zerkini (dependency injection) arabirimler üzerinden sağlıyorduk. Spring bize bunun daha gelişmişini sunuyor. @Annotation dediğimiz şerhler bağımlılık işlerini ve daha fazlasını çok daha kolay yönetmemizi sağlıyor. Mesela iş katmanında private olarak tuttuğunuz iMusteriDal isimli değişkenin tipini belirlemek için inşacı (constructor) yazabilirsiniz. Spring kullanıyorsanız inşacının tepesine @Autowired şerhi düşün. İnşacı çalıştığı anda tipinin ne olacağını spring kendi belirleyecek (mesela HibernateMusteriDal olabilir, NoSqlMusteriDal olabilir... Duruma göre.)
Spring'in çok daha fazla yeteneği var. Bizi ilgilendiren önemli bir tanesi MVC (Model View Controller) yapısı. Web arayüzüne sahip projelerimizde devreye giriyor. Ekranda görünen her web sayfası bir view'dır. Web sayfasındaki öğeler (mesela müşteri bilgileri, alım satım bilgileri) birer model'dir, veritabanından getirilir. Hangi view'ın görüntüleneceğini, web sayfası ile veritabanı arasında hangi modellerin getirilip götürüleceğini Controller belirler, ki en başta yaptığımız controller katmanı bunun ta kendisidir. Başında @RestController şerhi bulunur. İş katmanındaki sınıfların başında @Service şerhi, veri erişim katmanındakilerin başında ise @Repository şerhi bulunur.


8) SPRINGBOOT: Gördük ki maven harika birşey, hibernate de öyle, spring de öyle. Bunları her yeni projede kullanabiliriz ancak bunların ayarlarının elle yapılması zaman alıyor. Springboot bu işlemi çok kısa ve basit hale getiriyor bizim için. Tek yapmamız gereken https://start.spring.io/ adresinde nasıl bir proje istediğimizi belirtmek. Oluşturulan zip dosyasını indirip IDE'mizde (Eclipse, İntelliJ Idea, Netbeans vs) açmamız yeterli. Yeni bağımlılıklar eklemek istediğimizde proje içinde gelen pom.xml dosyasını düzenliyoruz, değişiklikler otomatik uygulanıyor, tabii internet bağlantısı olması lazım.
Eşantiyon bilgi: Boot kelimesi Türkçe'de çizme, bot anlamlarına geldiği gibi başlatma anlamına da gelebilir. Mesela bilgisayarı yeniden başlatmak için Reboot kelimesi kullanılır. Askerlikte acemi birliğinin İngilizce'si boot camp'tir, "başlatma kampı". Spring Boot'tan kasıt spring'i başlatmak için hazırlanmış yapıdır.

9) TOMCAT: Geliştirdiğimiz java uygulaması bir web arayüzüne sahip olacaksa, geliştirme yaptığımız esnada kodun ekranda nasıl göründüğünü kontrol etmek için bir sunucu / hosting hizmeti satın almamıza gerek yok. Nasıl ki MySql'i bilgisayarımıza kurduğumuzda kendi bilgisayarımızı bir veritabanı sunucusu haline getirebiliyorsak, tomcat'i kurduğumuzda da kendi bilgisayarımızı bir web sunucusu haline getirebiliyoruz. Not: Eğer springboot projesi ile çalışıyorsanız bilgisayara tomcat kurmaya gerek YOK! Springboot kendi dahili tomcat'iyle geliyor zaten. Siz elle tomcat kurmuşsanız ve çalışmakta ise springboot projeniz 8080 portuna erişemez. Önce kendi tomcat'inizin çalışmasını durdurun veya onu komple kaldırın, ondan sonra springboot projenizle çalışın.

10) IDE Önerisi: Ben şahsen IntelliJ Idea'yı tercih ediyordum ama bu kursta Engin Hocanın Eclipse'i kullandığını gördüm. Biraz internetten araştırdığımda sebebini anladım: IntelliJ Idea'nın Community yani ücretsiz versiyonunda Spring ve Tomcat desteği yok. Bunlar paralı sürüme has gözüküyor. Ama aslında Community sürüm de bunları destekliyor. https://start.spring.io/'dan bir proje indirin, IntelliJ Idea'nın community sürümünde bu projeyi açın. Herşeyin düzgün çalıştığını göreceksiniz. Idea, Eclipse'ten çok daha hızlı ve gelişmiş olduğu için Idea kullanmanızı öneririm.

Umarım faydalı olmuştur.